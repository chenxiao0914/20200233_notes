# 一、spring



## 1、spring控制事务的方式

编程式事务：手动编写事务进行处理，比如没使用mybatis等框架，直接使用Jdbc进行数据库操作。

声明式事务：通过xml配置扫描包和事务管理器。基于AOP实现，本质是对方法进行拦截，在方法开始之前创建或添加事务，方法之后提交或回滚事务。

# 二、Java基础

## 1、exception和error

exception：分为checked异常和unchecked异常（RuntimeException运行时异常：不需要try...catch...或者throws处理的异常）。一般是因为程序员没有进行必须的检查引起，如NullPointException、ArithmaticException、ArrayIndexoutofBoundsException。

error：系统错误或者底层资源的错误，一般为底层的不可恢复的类。

## 2、面向对象的特征有哪些方面？

- 抽象： 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 
- 封装：  通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。隐藏一切可隐藏的东西，只向外界提供最简单的编程接口 。
- 继承： 继承是从已有类得到继承信息创建新类的过程。  继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段 。
- 多态： 多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。 方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。 实现多态需要做两件事： 
  -  方法重写（子类继承父类并重写父类中已有的或抽象的方法）； 
  -  对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

## 3、String和基本数据类型

 Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。 

## 4、short s1 = 1; s1 += 1;有错吗？

  short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。 

## 5、int 和 Integer 有什么区别

 Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 

 原始类型: boolean，char，byte，short，int，long，float，double 

 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 

~~~java
	public static void main(String[] args) {
        Integer a = new Integer(3);
        Integer b = 3;
		// 将 3 自动装箱成 Integer 类型
        //当我们给一个 Integer 对象赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf
        int c = 3;
        System.out.println(a == b);
        // false 两个引用没有引用同一对象
        System.out.println(a == c);
        // true a 自动拆箱成 int 类型再和 c比较
    }
~~~

~~~java
	public static void main(String[] args) {
        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;
        System.out.println(f1 == f2);//false
        System.out.println(f3 == f4);//true
        //如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer对象，而是直接引用常量		//池中的Integer 对象
    }
~~~

